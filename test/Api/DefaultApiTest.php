<?php
/**
 * DefaultApiTest
 * PHP version 5
 *
 * @category Class
 * @package  TutuRu\LegalSuggesterClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
* Service suggestions api*
* No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)*
* OpenAPI spec version: 1.0.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.20
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Please update the test case below to test the endpoint.
 */

namespace TutuRu\LegalSuggesterClient;

use TutuRu\LegalSuggesterClient\Configuration;
use TutuRu\LegalSuggesterClient\ApiException;
use TutuRu\LegalSuggesterClient\ObjectSerializer;
use TutuRu\LegalSuggesterClient\Api\DefaultApi;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\Psr7\Response;
use TutuRu\Tests\Metrics\MemoryStatsdExporter\MemoryStatsdExporterClient;
use TutuRu\Tests\Metrics\MemoryStatsdExporter\MemoryStatsdExporterMetric;

/**
 * DefaultApiTest Class Doc Comment
 *
 * @category Class
 * @package  TutuRu\LegalSuggesterClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DefaultApiTest extends \PHPUnit\Framework\TestCase
{
    /** @var MemoryStatsdExporterClient */
    private $statsdExporterClient;

    /**
     * Setup before running any test cases
     */
    public static function setUpBeforeClass()
    {
    }

    /**
     * Setup before running each test case
     */
    public function setUp()
    {
        parent::setUp();
        $this->statsdExporterClient = new MemoryStatsdExporterClient("client");
    }

    /**
     * Clean up after running each test case
     */
    public function tearDown()
    {
    }

    /**
     * Clean up after running all test cases
     */
    public static function tearDownAfterClass()
    {
    }

    public function testDefaultConfig()
    {
        $api = new DefaultApi();
        $this->assertInstanceOf(Configuration::class, $api->getConfig());
    }

    public function apiMethodsDataProvider()
    {
        return [
        ['legalSuggesterServiceSuggestionsSearchGet'],
        ];
    }


    private function getApiMock(array $responses)
    {
        $config = new Configuration();
        $config->getHandlerStack()->setHandler(new MockHandler($responses));
        $config->setHost('localhost');
        $api = new DefaultApi(null, $config);
        $api->setStatsdExporterClient($this->statsdExporterClient);
        return $api;
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testSuccessCallApiMethod($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(200)]);
            $method = new \ReflectionMethod($api, $apiMethodName);
            call_user_func_array($method->getClosure($api), array_fill(0, $method->getNumberOfParameters(), ''));

            $this->assertSingleRequestTiming($apiMethodName, 'sync', 200);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testSuccessCallApiMethodWithHttpInfo($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(200)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'WithHttpInfo');
            call_user_func_array($method->getClosure($api), array_fill(0, $method->getNumberOfParameters(), ''));
            
            $this->assertSingleRequestTiming($apiMethodName, 'sync', 200);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testErrorCallApiMethod($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(500)]);
            $method = new \ReflectionMethod($api, $apiMethodName);

            call_user_func_array($method->getClosure($api), array_fill(0, $method->getNumberOfParameters(), ''));
            self::fail("No exception with 500-code mock handler");
        } catch (ApiException $e) {
            $this->assertSingleRequestTiming($apiMethodName, 'sync', 500);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testErrorCallApiMethodWithHttpInfo($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(500)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'WithHttpInfo');

            call_user_func_array($method->getClosure($api), array_fill(0, $method->getNumberOfParameters(), ''));
            self::fail("No exception with 500-code mock handler");
        } catch (ApiException $e) {
            $this->assertSingleRequestTiming($apiMethodName, 'sync', 500);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testSuccessAsyncCallApiMethod($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(200)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'Async');
            /** @var \GuzzleHttp\Promise\PromiseInterface $promise */
            $promise = call_user_func_array(
                $method->getClosure($api),
                array_fill(0, $method->getNumberOfParameters(), '')
            );
            $promise->wait();
            $this->assertSingleRequestTiming($apiMethodName, 'async', 200);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testSuccessAsyncCallApiMethodWithHttpInfo($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(200)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'AsyncWithHttpInfo');
            /** @var \GuzzleHttp\Promise\PromiseInterface $promise */
            $promise = call_user_func_array(
                $method->getClosure($api),
                array_fill(0, $method->getNumberOfParameters(), '')
            );
            $promise->wait();
            $this->assertSingleRequestTiming($apiMethodName, 'async', 200);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testErrorAsyncCallApiMethod($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(500)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'Async');
            /** @var \GuzzleHttp\Promise\PromiseInterface $promise */
            $promise = call_user_func_array(
                $method->getClosure($api),
                array_fill(0, $method->getNumberOfParameters(), '')
            );
            $promise->wait();
            self::fail("No exception with 500-code mock handler");
        } catch (ApiException $e) {
            $this->assertSingleRequestTiming($apiMethodName, 'async', 500);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    /**
     * @dataProvider apiMethodsDataProvider
     */
    public function testErrorAsyncCallApiMethodWithHttpInfo($apiMethodName)
    {
        try {
            $api = $this->getApiMock([new Response(500)]);
            $method = new \ReflectionMethod($api, $apiMethodName . 'AsyncWithHttpInfo');
            /** @var \GuzzleHttp\Promise\PromiseInterface $promise */
            $promise = call_user_func_array(
                $method->getClosure($api),
                array_fill(0, $method->getNumberOfParameters(), '')
            );
            $promise->wait();
            self::fail("No exception with 500-code mock handler");
        } catch (ApiException $e) {
            $this->assertSingleRequestTiming($apiMethodName, 'async', 500);
        } catch (\InvalidArgumentException $e) {
            $this->markTestSkipped("Argument with validation");
        }
    }


    private function assertSingleRequestTiming($apiMethodName, $queryType, $result)
    {
        $this->statsdExporterClient->save();

        $metrics = $this->statsdExporterClient->getExportedMetrics();
        $this->assertCount(1, $metrics);

        /** @var MemoryStatsdExporterMetric $metric */
        $metric = $metrics[0];
        $this->assertEquals('http_rest_client_api_request_duration', $metric->getName());
        $this->assertEquals('ms', $metric->getUnit());
        $this->assertGreaterThanOrEqual(0, $metric->getValue());

        $this->assertEquals($apiMethodName, $metric->getTags()['operation_id']);
        $this->assertEquals($queryType, $metric->getTags()['query_type']);
        $this->assertEquals($result, $metric->getTags()['status_code']);
        $this->assertEquals(Configuration::getServiceName(), $metric->getTags()['project']);
    }
}
